- ✅ **求最小满足条件的值**

---

```python
def binary_search_min(left, right, check):
    """
    在区间 [left, right) 内寻找最小的 x 使得 check(x) == True。
    约定右边界 right 为“不包含”。
    """
    while left < right:
        mid = (left + right) // 2
        if check(mid):
            # mid 可行，答案在 [left, mid]
            right = mid
        else:
            # mid 不可，答案在 [mid+1, right)
            left = mid + 1
    # 此时 left == right，即最小满足的 x
    return left
    
    
    
    
 def binary_search_min(left, right, check):
    """
    在区间 [left, right) 内寻找最小的 x 使得 check(x) == True。
    """
    while left <= right:
        mid = (left + right) // 2
        if check(mid):
            right = mid - 1   # mid 可行，往左收缩
        else:
            left = mid + 1    # mid 不可，往右找
    return left  # 最小满足 check 的 x

```

- ✅ **求最大满足条件的值**

```python
def binary_search_max(left, right, check):
    """
    在区间 (left, right] 内寻找最大的 x 使得 check(x) == True。
    约定左边界 left 为“不包含”，右边界 right 为“包含”。
    """
    while left < right:
        mid = (left + right + 1) // 2  # 注意加1避免死循环
        if check(mid):
            # mid 可行，答案在 [mid, right]
            left = mid
        else:
            # mid 不可，答案在 (left, mid-1]
            right = mid - 1
    # 此时 left == right，即最大满足的 x
    return left
    
    
    
    
def binary_search_max(left, right, check):
    """
    在区间 (left, right] 内寻找最大的 x 使得 check(x) == True。
    """
    while left <= right:
        mid = (left + right) // 2
        if check(mid):
            left = mid + 1   # mid 可行，往右找
        else:
            right = mid - 1  # mid 不可，往左找
    return right  # 最大满足 check 的 x

```

## 一、查第 k 小 元素

- **第 k 小**：最小的那个值 x，满足「原数组中 ≤ x 的元素个数 ≥ k」。

举例，对于数组 [7,2,5,3,9,4] 寻找第 3 小的元素：

- 值 4：数组中 ≤ 4 的元素有 {2,3,4}，共 3 个，满足 ≥ 3。
- 若尝试更小的值 3，则 ≤ 3 的元素只有 2 个，不满足条件。
- 因此第 3 小的元素是 4。

### 1. 判定函数 `check_small`

判断数组 `nums` 中 **小于等于** 值 `x` 的元素是否 **至少** 有 k 个。

```python
def check_small(nums, x, k):
    """
    判断 nums 中 ≤ x 的元素数量是否 ≥ k
    如果 ≥ k，则说明「第 k 小的值」不大于 x，返回 True；
    否则返回 False。
    """
    count = 0
    # 遍历 nums，统计 ≤ x 的元素数量
    for value in nums:
        if value <= x:
            count += 1
        # 如果已经足够 k 个，可以提前结束
        if count >= k:
            # 说明满足条件，直接返回 True
            return True

    # 遍历结束，仍未达到 k 个，返回 False
    return False

```

### 2. 二分模板

```python
def kth_smallest(nums, k):
    # 1) 值域的上下界
    low = min(nums)    # 值域下界
    high = max(nums)   # 值域上界

    # 2) 判定函数同上：check_small(nums, mid, k)

    # 3) 在 [low, high] 上进行二分
    while low < high:
        mid = (low + high) // 2
        # 如果 mid 太大（或正好够），第 k 小 ≤ mid
        if check_small(nums, mid, k):
            high = mid      # 答案在 [low, mid]
        else:
            low = mid + 1   # 答案在 (mid, high]

    # 4) 当 low == high 时，收敛到第 k 小元素的值
    return low

```

---

## 二、查第 k 大 元素

- **第 k 大**：最大的那个值 x，满足「原数组中 ≥ x 的元素个数 ≥ k」。

### 1. 判定函数 `check_large`

判断数组 `nums` 中 **大于等于** 值 `x` 的元素是否 **至少** 有 k 个。

```python
def check_large(nums, x, k):
    """
    判断 nums 中 ≥ x 的元素数量是否 ≥ k
    如果 ≥ k，则说明「第 k 大的值」不小于 x，返回 True；
    否则返回 False。
    """
    count = 0
    for value in nums:
        if value >= x:
            count += 1
        if count >= k:
            return True
    return False
```

### 2. 二分模板

```python
def kth_largest(nums, k):
    # 1) 值域上下界
    low = min(nums)
    high = max(nums)

    # 2) 判定函数同上：check_large(nums, mid, k)

    # 3) 注意取“上中位”以防死循环
    while low < high:
        # 向上取整
        mid = (low + high + 1) // 2
        # 如果 mid 太小（或正好够），第 k 大 ≥ mid
        if check_large(nums, mid, k):
            low = mid       # 答案在 [mid, high]
        else:
            high = mid - 1  # 答案在 [low, mid)

    # 4) low == high，即为第 k 大元素的值
    return low

```
